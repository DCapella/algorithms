1. Describe an analogy for relating an algorithm that has efficiency O(1) and
another algorithm that has O(2n). An example would be:
An algorithm that has O(1) is a Cheetah and an algorithm that has O(2n) is a Snail.

  An algorithm that has O(1) is a jet and an algorithm that has O(2n) is a Junkers F13.

2. In plain English, what is the best case scenario for binary search?

  O(1).

3. In plain English, what is the worst-case scenario for binary search?

  log(n)

4. In plain English, what is the bounded-case scenario for binary search?

  log(n/2)

5. Create a graph using the data below. Here's a CSV with the values you'll need.



6. What is the limit of the function above as n approaches infinity?

  lim n => 2^n

7. What is the Big-O of an algorithm that has the data points above?

  f(n) = 2^n or O(2^n)

8. Write a Ruby method that takes a number n. This method must print the
worst-case number of iterations for linear search to find an item in
collections of size one to n. Use it to generate a table of worst-case
iterations of collections up to size 10.

def ruby_method(n)
  puts n
end

9. Create a graph from the output using Google Sheets or other graphing
software. Analyze the graph and denote its Big-O somewhere on the graph.

10. What is the Big-O of binary search?

  O(1)

11. What is the Big-Ω of binary search?

  log(n)

12. What is the Big-Ө of binary search?

  log(n/2)
